<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StateTemplate Client Demo</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f5f5;
      }

      .dashboard {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .metric {
        display: inline-block;
        margin: 10px;
        padding: 15px 20px;
        background: #007acc;
        color: white;
        border-radius: 5px;
        min-width: 120px;
        text-align: center;
      }

      .metric.warning {
        background: #ff9500;
      }

      .metric.danger {
        background: #ff3b30;
      }

      .controls {
        margin: 20px 0;
      }

      button {
        margin: 5px;
        padding: 10px 15px;
        border: none;
        border-radius: 5px;
        background: #007acc;
        color: white;
        cursor: pointer;
      }

      button:hover {
        background: #005999;
      }

      .log {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 15px;
        border-radius: 5px;
        font-family: "SF Mono", Monaco, monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
        margin: 20px 0;
      }

      .message {
        margin: 5px 0;
        padding: 8px;
        background: #f0f0f0;
        border-radius: 4px;
        border-left: 3px solid #007acc;
      }

      h1 {
        color: #333;
        margin-bottom: 10px;
      }

      h2 {
        color: #666;
        margin-top: 30px;
        margin-bottom: 15px;
      }
    </style>
  </head>
  <body>
    <h1>StateTemplate Client Demo</h1>
    <p>
      This demo shows real-time HTML updates using the StateTemplate client
      library.
    </p>

    <div class="controls">
      <button onclick="updateMetrics()">Update Metrics</button>
      <button onclick="addAlert()">Add Alert</button>
      <button onclick="addMessage()">Add Message</button>
      <button onclick="clearMessages()">Clear Messages</button>
      <button onclick="resetDemo()">Reset Demo</button>
    </div>

    <div id="app">
      <div class="dashboard">
        <h2>System Metrics</h2>
        <div id="cpu" class="metric">CPU: 15%</div>
        <div id="memory" class="metric">Memory: 45%</div>
        <div id="disk" class="metric">Disk: 60%</div>

        <h2>Alerts</h2>
        <div id="alerts"></div>

        <h2>Messages</h2>
        <div id="messages"></div>
      </div>
    </div>

    <h2>Update Log</h2>
    <div id="log" class="log"></div>

    <script src="../dist/index.js"></script>
    <script>
      // Initialize demo state
      let messageCount = 0;
      let updateCount = 0;
      let client = null;
      let autoUpdateInterval = null;

      // Logging function
      function log(message) {
        const logDiv = document.getElementById("log");
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // Initialize the StateTemplate client after DOM is loaded
      function initializeClient() {
        try {
          // The UMD bundle exports StateTemplateClient as a property of the global StateTemplateClient object
          client = new StateTemplateClient.StateTemplateClient({
            debug: true,
          });
          log("StateTemplate Client initialized successfully");

          // Start auto-update only after client is ready
          autoUpdateInterval = setInterval(updateMetrics, 5000);
          log("Auto-updating metrics every 5 seconds");
        } catch (error) {
          log(`Error initializing client: ${error.message}`);
        }
      }

      // Demo functions
      async function updateMetrics() {
        if (!client) {
          log("Client not initialized yet, skipping metrics update");
          return;
        }

        const cpu = Math.floor(Math.random() * 100);
        const memory = Math.floor(Math.random() * 100);
        const disk = Math.floor(Math.random() * 100);

        const updates = [
          {
            fragment_id: "cpu",
            html: `<div id="cpu" class="metric ${
              cpu > 80 ? "danger" : cpu > 60 ? "warning" : ""
            }">CPU: ${cpu}%</div>`,
            action: "replace",
          },
          {
            fragment_id: "memory",
            html: `<div id="memory" class="metric ${
              memory > 80 ? "danger" : memory > 60 ? "warning" : ""
            }">Memory: ${memory}%</div>`,
            action: "replace",
          },
          {
            fragment_id: "disk",
            html: `<div id="disk" class="metric ${
              disk > 80 ? "danger" : disk > 60 ? "warning" : ""
            }">Disk: ${disk}%</div>`,
            action: "replace",
          },
        ];

        try {
          const results = await client.applyUpdates(updates);
          const successful = results.filter((r) => r.success).length;
          log(`Updated ${successful}/${results.length} metrics`);
        } catch (error) {
          log(`Error updating metrics: ${error.message}`);
        }
      }

      async function addAlert() {
        if (!client) {
          log("Client not initialized yet, cannot add alert");
          return;
        }

        const alerts = [
          "High CPU usage detected",
          "Memory usage above threshold",
          "Disk space running low",
          "Network connectivity issues",
          "Service response time high",
        ];

        const alert = alerts[Math.floor(Math.random() * alerts.length)];
        const severity = Math.random() > 0.7 ? "danger" : "warning";

        try {
          const result = await client.applyUpdate({
            fragment_id: "alerts",
            html: `<div class="message" style="border-left-color: ${
              severity === "danger" ? "#ff3b30" : "#ff9500"
            }">${alert}</div>`,
            action: "append",
          });

          if (result.success) {
            log(`Added alert: ${alert}`);
          } else {
            log(`Failed to add alert: ${result.error?.message}`);
          }
        } catch (error) {
          log(`Error adding alert: ${error.message}`);
        }
      }

      async function addMessage() {
        if (!client) {
          log("Client not initialized yet, cannot add message");
          return;
        }

        messageCount++;
        const messages = [
          "System backup completed successfully",
          "New user registered",
          "Database optimization finished",
          "Security scan completed",
          "Cache refreshed",
          "Service restarted",
        ];

        const message = messages[Math.floor(Math.random() * messages.length)];

        try {
          const result = await client.applyUpdate({
            fragment_id: "messages",
            html: `<div class="message">[${messageCount}] ${message}</div>`,
            action: "append",
          });

          if (result.success) {
            log(`Added message: ${message}`);
          } else {
            log(`Failed to add message: ${result.error?.message}`);
          }
        } catch (error) {
          log(`Error adding message: ${error.message}`);
        }
      }

      async function clearMessages() {
        if (!client) {
          log("Client not initialized yet, cannot clear messages");
          return;
        }

        try {
          const result = await client.applyUpdate({
            fragment_id: "messages",
            html: '<div id="messages"></div>',
            action: "replace",
          });

          if (result.success) {
            messageCount = 0;
            log("Cleared all messages");
          } else {
            log(`Failed to clear messages: ${result.error?.message}`);
          }
        } catch (error) {
          log(`Error clearing messages: ${error.message}`);
        }
      }

      function resetDemo() {
        if (autoUpdateInterval) {
          clearInterval(autoUpdateInterval);
        }
        location.reload();
      }

      // Initialize when DOM is loaded
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeClient);
      } else {
        // DOM is already loaded
        initializeClient();
      }
    </script>
  </body>
</html>
